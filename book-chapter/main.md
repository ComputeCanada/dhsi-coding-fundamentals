---
title: "Computing Foundations for Human(s|ists)"
authors:
- Dennis Tenen
- John Simpson

---

We write this chapter in reflection of teaching **Computing Foundations for
Human Human(s|ists)** at the Digital Humanities Summer Institute, University of
Victoria. This week-long course was intended for humanities-based researchers
with no previous programming experience, and, as we wrote in the course
description, for those who would like to understand how programs work by
writing a few simple, but useful programs of their own.[^ln-courselink] The
topics covered included working with files and folders at the command line,
text stream manipulation with Bash Unix Shell, regular expressions, along with
Python basics like native data types, variables, functions, and control
structures. At the end of the course our students worked on their own and in
small groups to create a small web scraper, an "essay grader," a comma
separated value file manipulator, and a program that evaluated poetry for its
measure of similarity to Byron.

Our aim in this chapter is not so much to recreate that experience (we would
not have the space to do it here, in any case) but to reveal some of the ideas
that went into making the course, to talk about the rationale behind our
teaching philosophy, and, more broadly, to suggest an approach of teaching
programming in the humanities environment.

## Critical Computing in the Humanities

It is our firm belief that the teaching of computational principles in the
humanities must happen in context: that is, grounded in the practice of
humanities-based research and answering to the values held by the academic
community.  We call this approach critical computing, which for us involves the
following eight principles:

[^ln-courselink]: An archived version of the course can be accessed at
http://web.archive.org/web/20150614161609/https://github.com/denten-workshops/dhsi-coding-fundamentals/blob/master/README.md

1. No black boxes!  

Computers are everywhere. They mediate everything from financial markets, to
archival research, and to the way many keep in touch with their friends and
family. Yet, for those without computational background, these devices remain a
source of mystery, magic, and frustration. Our course begins then with a
process of demystification. We want our students to understand not only the
principles of computer science, but the basics of software and electrical
engineering. As much as possible, we would loke to reveal the innards of opaque
computational "black boxes," empowering our students to take control of their
everyday computational practice.

2. Use few, free, small, simple, universal, and powerful tools that you can hack and
understand.

Librarians, students, and faculty are faced with a bewildering array of
software choices. Companies that promise "innovation" and "disruption" in the
classroom routinely approach administrators with offers of

3. Wherever possible store data in human-readable text streams.

Do it right. Doing it badly accumulates intellectual, technological, and
ethical debt.

If you have to do something more than once a hundred times,† automate.

Divide big problems into small, modular components.

Bootstrap and time well spent.‡

Keep poking, get help, take notes, comment, annotate, share, remix, and train
others.
